<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class TelegramService
{
    private string $botToken;
    private string $chatId;
    private string $apiUrl;

    public function __construct()
    {
        $this->botToken = config('telegram.bot_token', env('TELEGRAM_BOT_TOKEN', ''));
        $this->chatId = config('telegram.chat_id', env('TELEGRAM_CHAT_ID', ''));
        $this->apiUrl = "https://api.telegram.org/bot{$this->botToken}";
    }

    /**
     * Send message to Telegram
     */
    public function sendMessage(string $message, array $options = []): bool
    {
        if (empty($this->botToken) || empty($this->chatId)) {
            Log::warning('Telegram credentials not configured');
            return false;
        }

        try {
            $payload = array_merge([
                'chat_id' => $this->chatId,
                'text' => $message,
                'parse_mode' => 'HTML',
                'disable_web_page_preview' => true,
            ], $options);

            $response = Http::timeout(10)->post("{$this->apiUrl}/sendMessage", $payload);

            if ($response->successful()) {
                Log::info('Telegram message sent successfully', [
                    'message_length' => strlen($message),
                    'response' => $response->json(),
                ]);
                return true;
            } else {
                Log::error('Failed to send Telegram message', [
                    'status' => $response->status(),
                    'response' => $response->json(),
                ]);
                return false;
            }
        } catch (\Exception $e) {
            Log::error('Telegram service error', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
            return false;
        }
    }

    /**
     * Send formatted analysis result to Telegram
     */
    public function sendAnalysisResult(string $coinCode, object $analysis, float $currentPrice): bool
    {
        $signal = strtoupper($analysis->signal);
        $confidence = $analysis->confidence;
        $signalEmoji = $this->getSignalEmoji($signal);
        $signalColor = $this->getSignalColor($signal);

        $message = "ğŸš¨ <b>HIGH CONFIDENCE SIGNAL</b> ğŸš¨\n\n";
        $message .= "ğŸ“ˆ <b>Coin:</b> {$coinCode}\n";
        $message .= "ğŸ¯ <b>Signal:</b> <span style='color: {$signalColor}'>{$signalEmoji} {$signal}</span>\n";
        $message .= "ğŸ“Š <b>Confidence:</b> {$confidence}%\n";
        $message .= "ğŸ’° <b>Current Price:</b> $" . number_format($currentPrice, 4) . "\n";
        $message .= "ğŸ¯ <b>Entry:</b> $" . number_format($analysis->entry, 4) . "\n";
        $message .= "ğŸ›‘ <b>Stop Loss:</b> $" . number_format($analysis->stop_loss, 4) . "\n";
        $message .= "âœ… <b>Take Profit:</b> $" . number_format($analysis->take_profit, 4) . "\n";
        $message .= "ğŸ“ˆ <b>Risk:Reward:</b> {$analysis->risk_reward}\n\n";

        if (isset($analysis->notes) && !empty($analysis->notes)) {
            $message .= "ğŸ“ <b>Notes:</b>\n{$analysis->notes}\n\n";
        }

        $message .= "âš¡ <i>Generated by Crypto Analysis System</i>";

        return $this->sendMessage($message);
    }

    /**
     * Get emoji for signal type
     */
    private function getSignalEmoji(string $signal): string
    {
        return match (strtoupper($signal)) {
            'BUY' => 'ğŸ“ˆ',
            'SELL' => 'ğŸ“‰',
            'NEUTRAL' => 'â–',
            default => 'â“'
        };
    }

    /**
     * Get color for signal type
     */
    private function getSignalColor(string $signal): string
    {
        return match (strtoupper($signal)) {
            'BUY' => '#00ff00',
            'SELL' => '#ff0000',
            'NEUTRAL' => '#ffff00',
            default => '#ffffff'
        };
    }

    /**
     * Check if Telegram is properly configured
     */
    public function isConfigured(): bool
    {
        return !empty($this->botToken) && !empty($this->chatId);
    }
}